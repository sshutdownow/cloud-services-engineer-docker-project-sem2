# Проектная работа дисциплины «Docker-контейнеризация и хранение данных»

## Описание
В этой проектной работе нужно настроить контейнеризацию существующего приложения с использованием Docker и Docker Compose, а также обеспечить безопасность образов и контейнеров.

Изначально в проекте две части:
* backend — бэкенд приложения (Go).
* frontend — фронтенд приложения (Vue.js).

В рамках проекта выполнены следующие задачи:
* Оптимизированы Dockerfile для:
  * бэкенда: go-приложение собрано статически, для его запуска используется [пустой контейнер](https://hub.docker.com/_/scratch/), для healtheck добавленно [простое приложение на go](backend/cmd/healthcheck), тоже собранно статически. Размер image после развёртывания - 16.5MB.
  * фронтенд: в качестве основы взят легковесный образ nginx:stable-alpine, добавлен [.dockergnore](https://cli.vuejs.org/ru/guide/deployment.html#docker-nginx). Размер image после развёртывания - 53.6MB.
* Добавлен ещё один контейнер - `gateway`, он использует image `haproxy:lts-alpine` (размер на диске 32.3MB), `gateway` выполняет функцию балансировщика нагрузки. Он [использует DNS-резолвер докера для обнаружения](https://www.haproxy.com/blog/haproxy-on-docker-swarm-load-balancing-and-dns-service-discovery) добавления/удаления backend-серверов. Т.е. если мы меняем число экземпляров контейнеров go-бэкенд и/или и vue-фронтенд, haproxy это тут же обнаруживает и начинает распределять нагрузку по всем рабочим контейнерам. Это позволяет быстро адаптировать проект под изменения нагрузки.
* Настроен Docker Compose для оркестрации контейнеров - haproxy запускается только по готовности бэкенда и фронтенда.
* Реализованы меры безопасности: haproxy - это единственный контейнер, который доступен напрямую из внешней сети (Интернет), с остальными контейнерами он коммуницирует в рамках отдельной внутренней сети. Внутри всех контейнеров нет процессов, запущеных от root.

  
